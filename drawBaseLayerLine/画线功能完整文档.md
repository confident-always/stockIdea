# 画线功能完整文档

> 本文档整合了 drawBaseLayerLine 目录中的所有画线功能说明文档
> 
> 最后更新时间: 2025-10-24

---

## 目录

1. [AnchorM线功能说明](#anchorm线功能说明)
2. [AnchorBack线功能说明](#anchorback线功能说明)
3. [AnchorBack更新日志](#anchorback更新日志)

---

# AnchorM线功能说明

## 功能概述

AnchorM线功能是一个动态M值优化系统,通过遍历不同的M值(13.0%到9.0%),计算B序列并与ZigZag拐点附近的极值进行匹配评分,自动选择最佳M值并在图表上绘制相应的紫色横线标注。

**v2.0 新增特性**:
- ⏰ **时间衰减因子**: 离锚定点越近的极值点得分权重越高,更关注近期价格行为
- 🎯 **智能匹配调整**: 根据数据量自动调整匹配数要求
- 📈 **K值自动扩展**: 完全覆盖所有K线并额外绘制3根预测线
- 🎨 **优化显示**: 左上角信息框,只显示匹配的B值及得分

## 核心算法

### 1. 锚点确定
- 使用现有的阶段低点检测逻辑(ZigZag 49%)
- 锚点低价A = 阶段低点价格
- 锚定日期 = 阶段低点日期

### 2. 小级别ZigZag计算
- 参数p: 默认10%(可配置)
- 在锚定日期之后的数据中计算ZigZag转折点
- 提取拐点附近窗口(±3个交易日)的局部极值

### 3. M值遍历与B序列生成
- M值范围: 13.0% → 9.0%, 步长0.1%
- B序列公式: B_k = A + (A × M) × k
  - k = 1, 2, 3, ... 最多20个
  - 停止条件: B_k > 最高价 × 1.01

### 4. 匹配与评分（含时间衰减因子）
对每个B_k:
- 找到最接近的两个极值(一上一下)
- 计算基础得分:
  - 相对差: r = |E - B_k| / B_k
  - 基础得分: base_score = 100 × max(0, 1 - min(r / 0.006, 1))
- 应用时间衰减权重:
  - 时间权重: time_weight = 1.0 - (1.0 - min_weight) × (idx / max_idx)
  - idx: 极值点距锚定点的天数
  - min_weight: 最小权重(默认0.3)
- 最终得分: final_score = base_score × time_weight
- B_k得分 = 选中极值的加权平均得分

时间衰减规则:
- 锚定点附近(idx≈0): 权重 ≈ 1.0 (100%)
- 中间位置(idx≈max/2): 权重 ≈ 0.65 (65%)
- 最远位置(idx=max): 权重 = min_weight (30%)

M值总分:
- 平均得分 = 所有B_k加权得分的平均值
- 匹配数 = 得分>0的B_k数量

### 5. 最佳M选择
- 过滤: 匹配数 < 3的M值被排除
- 排序: 优先平均得分,其次匹配数,最后M值大小
- 选择: 得分最高的M值

## 配置参数 (lineConfig.json)

```json
{
  "anchorMLines": {
    "enabled": true,                      // 启用/禁用功能
    "zigzag_percent": 10,                 // 小级别ZigZag阈值(%)
    "time_decay_min_weight": 0.3,         // 时间衰减最小权重(0-1)
                                          // 0.3 - 中等衰减(默认,推荐)
                                          // 0.5 - 温和衰减(兼顾历史)
                                          // 0.1 - 强烈衰减(重视近期)
                                          // 1.0 - 无衰减(等同原算法)
    "pivot_window": 3,                    // 拐点窗口大小
    "m_range": {
      "start": 13.0,                      // M值起始(%)
      "end": 9.0,                         // M值结束(%)
      "step": -0.1                        // M值步长(%)
    },
    "max_k": 20,                          // 最大K值(已自动扩展,无实际限制)
    "match_tolerance_ratio": 0.006,       // 匹配容差(0.6%)
    "min_matches": 3,                     // 最小匹配数要求(自动智能调整)
    "tiebreaker_prefer_higher_M": true,   // 并列时优先更大M
    "line_style": {
      "color": "#8A2BE2",                 // 线条颜色(紫色)
      "linewidth": 3.0,                   // 线宽
      "alpha": 0.9                        // 透明度
    },
    "text_style": {
      "fontsize": 14,                     // 字号
      "x_offset": 5                       // X轴偏移
    },
    "annotate_format": "K={K} 价格={price}",  // 标注格式
    "anchor_fallback_window_days": 60     // 回退窗口(天)
  }
}
```

## 输出内容

### 1. 图表上的紫色横线
- 显示用于评分的小级别极值
- 每条横线对应一个匹配的极值价格
- 线旁标注: "K=X 价格=Y.YY"

### 2. 左上角信息框
```
M=11.1%
Match_B: [13.79(34), 17.92(27), ...]
AvgScore: 8.7
Matches: 2/7
```
说明:
- M值: 选出的最佳M百分比
- Match_B: 只显示匹配的B值及其得分
- AvgScore: 平均得分(含时间衰减后的加权得分)
- Matches: 有效匹配数/总B值数

### 3. JSON结果
保存在 `processing_results.json` 中:
```json
{
  "stock_code": "002603",
  "stock_name": "以岭药业",
  "success": true,
  "anchorMLines": {
    "best_M": 11.1,
    "avg_score": 8.7,
    "matches_count": 2,
    "scores": [
      {"B_k": 13.79, "score": 34},
      {"B_k": 17.92, "score": 27}
    ],
    "anchor_low": 12.41,
    "anchor_date": "2025-04-09"
  }
}
```
注: scores数组只保存有效匹配(得分>0)的B值及其得分

## 使用方法

### 基本用法
```bash
# 默认处理(功能自动启用,含时间衰减)
cd drawBaseLayerLine
python draw_lines_mid.py --date 2025-10-21 --workers 4
```

### 禁用M线功能
修改 `lineConfig.json`:
```json
{
  "anchorMLines": {
    "enabled": false
  }
}
```

### 调整参数
```json
{
  "anchorMLines": {
    "zigzag_percent": 5,          // 更灵敏的小级别ZigZag
    "time_decay_min_weight": 0.5, // 温和衰减,更兼顾历史数据
    "min_matches": 5,             // 更严格的匹配要求(会自动调整)
    "match_tolerance_ratio": 0.01 // 更宽松的容差(1%)
  }
}
```

## 技术实现

### 核心函数
1. `zigzag()` - 计算ZigZag转折点
2. `get_local_extremes_around_turns()` - 提取拐点附近极值
3. `generate_B_series()` - 生成B序列(自动扩展到覆盖所有K线+3根)
4. `score_M()` - M值评分(含时间衰减因子)
5. `select_best_M()` - 选择最佳M
6. `compute_anchor_M_lines()` - 主计算函数
7. `find_stage_lows_unified()` - 阶段低点检测(含优化)

### 绘图集成
- 在 `create_mid_chart()` 中集成
- 使用 `ax.axhline()` 绘制横线
- 使用 `ax.text()` 在左侧添加K值标注
- 使用 `ax.text()` 在左上角添加M值信息框
- 线程安全,支持多线程处理

## 性能特点

- **线程安全**: 无共享可变状态
- **高效计算**: O(n)时间复杂度
- **智能调整**:
  - K值自动扩展(覆盖所有K线+3根)
  - 匹配数自动调整(数据少时降低要求)
  - 时间衰减自动应用
- **鲁棒性强**: 
  - 数据不足时安全退出(附详细日志)
  - 无匹配时不绘制
  - 异常捕获不中断流程

## 应用场景

### 场景1: 震荡市场
- 小级别ZigZag捕捉频繁转折
- M值评分识别主要支撑/压力位
- 紫色横线标注关键价格点

### 场景2: 趋势市场
- 较大的M值(接近13%)匹配趋势
- 较少的匹配点(3-5个)
- 清晰的上升通道

### 场景3: 数据不足(智能处理)
- 锚定日期后数据<10天: 跳过(日志提示)
- ZigZag无转折点: 跳过(日志提示)
- 数据<200天: 自动降低最小匹配数(3→2)
- 匹配数不足: 跳过并显示实际匹配数

## 测试结果

### 002603 以岭药业(含时间衰减)
- 锚点: 2025-04-09, 12.41元
- 锚定后数据: 129天
- 最佳M: 11.1%
- 平均得分: 8.7(时间衰减后)
- 匹配: 2/7
- 匹配B值: 13.79(34分), 17.92(27分)
- 智能调整: 最小匹配数 3→2
- ✅ 功能正常,时间衰减生效

### 时间衰减效果对比
无时间衰减:
- 平均得分: 15.5
- 13.79元得分: 45
- 17.92元得分: 63

含时间衰减(0.3):
- 平均得分: 8.7 (↓44%)
- 13.79元得分: 34 (↓24%)
- 17.92元得分: 27 (↓57%)

说明: 远期极值点(17.92)衰减更明显,符合预期

## 调优建议

### 提高灵敏度(捕捉更多细节)
```json
{
  "zigzag_percent": 5,           // 更小阈值,更多转折点
  "time_decay_min_weight": 0.2,  // 强烈衰减,重视近期
  "min_matches": 2,              // 降低要求(会自动调整)
  "match_tolerance_ratio": 0.01  // 放宽容差
}
```

### 提高准确性(筛选高质量)
```json
{
  "zigzag_percent": 15,          // 更大阈值,主要转折
  "time_decay_min_weight": 0.5,  // 温和衰减,兼顾历史
  "min_matches": 5,              // 提高要求
  "match_tolerance_ratio": 0.003 // 收紧容差
}
```

### 重视近期行为
```json
{
  "time_decay_min_weight": 0.1,  // 强烈衰减
  "zigzag_percent": 8            // 适中阈值
}
```

### 兼顾历史规律
```json
{
  "time_decay_min_weight": 0.6,  // 温和衰减
  "zigzag_percent": 12           // 较大阈值
}
```

### 调整M值范围
```json
{
  "m_range": {
    "start": 15.0,    // 更大M值
    "end": 8.0,       // 更小M值
    "step": -0.05     // 更细步长(计算量翻倍)
  }
}
```

## 注意事项

1. **计算开销**: M值遍历会增加计算时间(约+10-20%)
2. **视觉效果**: 
   - 紫色横线已优化(加粗,左侧标注)
   - 信息框移至左上角
   - 只显示匹配的B值及得分
3. **数据质量**: 依赖高质量的K线数据
4. **参数调优**: 不同市场环境需要不同参数
5. **时间衰减**: 
   - 默认0.3适合大多数场景
   - 设为1.0可禁用时间衰减
   - 调整时注意平均得分会相应变化
6. **智能特性**:
   - K值自动扩展,无需担心上限
   - 匹配数自动调整,数据少时自动降低要求

## 未来优化方向

1. ~~自适应M值范围(根据市场波动率)~~
2. ~~多级别M线(不同时间周期)~~
3. M值趋势分析(M值随时间变化)
4. 机器学习优化参数
5. ~~时间衰减因子~~ ✅ 已实现(v2.0)
6. 非线性时间衰减(指数衰减、对数衰减等)

## AnchorM更新日志

### v2.0 (2025-10-21)
✅ **时间衰减因子**: 
- 加入时间维度权重,近期极值点得分更高
- 可配置衰减强度(time_decay_min_weight)
- 默认0.3,兼顾近期和历史

✅ **智能匹配数调整**:
- 根据锚定后数据量自动调整min_matches
- 数据<200天: 3→2, 避免过度筛选

✅ **K值自动扩展**:
- 解除max_k=20限制
- 自动覆盖所有K线+3根预测线
- 安全上限500防止极端情况

✅ **显示优化**:
- 信息框移至左上角
- 只显示匹配的B值及得分
- K值标注加粗放大,移至左侧

### v1.0 (2025-10-20)
- 初始版本
- 基础M线功能
- ZigZag匹配评分

---

# AnchorBack线功能说明

## 功能概述

`draw_line_back.py` 是一个基于 **AnchorBack算法** 的K线图表生成脚本，与 `draw_lines_mid.py`（AnchorM算法）形成对比。

## 核心算法：AnchorBack

### 算法公式

```
B_k = A + N × K
```

其中：
- **A**: 锚定低点日期前后5天（共11天）内所有收盘价中的**最低收盘价**
- **N**: 步长参数 (范围: 0.23 ~ 0.68, 步长: 0.01)
- **K**: 奇数序列，自动生成以覆盖所有K线并额外绘制3条预测线

### 与AnchorM的区别

| 特性 | AnchorBack | AnchorM |
|------|-----------|---------|
| 算法公式 | `B = A + N × K` (加法) | `B = A × (1 + M × k)` (乘法) |
| 参数名称 | N (步长) | M (百分比) |
| 参数范围 | 0.23 ~ 0.68 | 9.0% ~ 13.0% |
| K值序列 | 奇数 (1,3,5...) 自动生成 | 连续整数 (1,2,3...) |
| 线条颜色 | 蓝色 (#1E90FF) | 紫色 (#8A2BE2) |
| 锚定点A | 11天窗口内最低**收盘价** | 5根K线窗口内最低**收盘价** |
| K值数量 | 自动计算（覆盖全部+3条） | 自动计算（覆盖全部+3条） |

## 使用方法

### 基本用法

```bash
# 处理指定日期的股票
python draw_line_back.py --date 2025-10-22

# 指定线程数
python draw_line_back.py --date 2025-10-22 --workers 4
```

### 配置文件

脚本使用 `lineConfig.json` 中的 `anchorBackLines` 配置：

```json
"anchorBackLines": {
    "enabled": true,
    "zigzag_percent": 15,
    "time_decay_min_weight": 0.3,
    "pivot_window": 7,
    "n_range": {
        "start": 0.23,
        "end": 0.68,
        "step": 0.01
    },
    "k_list": [1, 3, 5, 7, 9, 11, 13, 15, 17, 19],
    "match_tolerance_ratio": 0.006,
    "min_matches": 2,
    "tiebreaker_prefer_higher_N": true,
    "line_style": {
        "color": "#1E90FF",
        "linewidth": 3.0,
        "alpha": 0.9
    }
}
```

## 输出说明

### 图表元素

1. **蓝色横线**: AnchorBack线（`B_k = A + N × K`）
2. **左侧蓝色标签**: K值和价格 (如 "K=1 价格=6.45")
3. **锚定点标注**: 
   - 红色圆点（白色边框）标记最低收盘价位置
   - 黄色标签显示 "Anchor {price}"
   - 红色箭头指向锚定点
4. **右侧蓝色标签**: 阶段低点价格
5. **右侧棕色标签**: 百分比涨幅线 (+3%, +16%, +25%...)
6. **左上角信息框**: 
   - N值
   - Match_B数组（匹配的K值、价格、得分）
   - 平均得分
   - 匹配数量

### 输出目录

```
{日期}-drawLineBack/
  ├── ADX105_002064_华峰化学_2back.png
  ├── PDI39_600323_瀚蓝环境_2back.png
  └── ...
```

## 算法详解

### 1. 锚定点确定

1. 使用ZigZag(49%)算法找到阶段性低点
2. 找到该低点对应的日期
3. 在该日期前后5天（共11天）的窗口内
4. 取所有**收盘价**中的最小值作为锚定点A

**为什么用11天窗口？**
- 相比5根K线窗口，11天窗口能更准确地捕捉局部最低点
- 避免因单日极端波动导致的锚点偏差
- 提供更稳定的支撑位参考

**为什么用收盘价？**
- 收盘价代表当天买卖双方最终共识
- 比最低价（可能是盘中瞬时价格）更稳定
- 更适合作为支撑位参考

### 2. K值自动生成

```python
# 计算需要多少个K值才能覆盖到最高价
k_to_reach_max = int((max_price - A) / N)

# 确保K是奇数
if k_to_reach_max % 2 == 0:
    k_to_reach_max += 1

# 在覆盖最高价的基础上再加3个奇数（+2, +4, +6）
k_final = k_to_reach_max + 6

# 生成奇数序列：1, 3, 5, 7, 9, ...
k_values = list(range(1, k_final + 1, 2))
```

### 3. N值遍历与评分

1. 对每个N值（0.23 ~ 0.68），生成B序列
2. 使用ZigZag(15%)算法找到锚定点后的转折点
3. 提取转折点附近的局部极值：
   - **高点转折**: 取窗口内最高价
   - **低点转折**: 取窗口内最低收盘价

4. 计算匹配得分：
   - 对每个B_k，找最近的两个极值点
   - 计算价格相似度得分（容差0.6%）
   - 应用时间衰减因子（离锚定点越近权重越高）

5. **动态N值调整**：
   - 如果匹配数 < 2，尝试降低N值
   - 优先选择能获得 >= 2 个匹配的N值
   - 在相同匹配数下，优先选择更小的N值（更密集）

### 4. 图表绘制

1. 显示范围：从锚定低点开始（确保锚定点可见）
2. 绘制蓝色AnchorBack线
3. 标注锚定点（红色圆点+黄色标签）
4. 添加K值标签和信息框

## 实战应用

### 场景1：验证算法起点
- 查看红色锚定点位置
- 确认是最低收盘价
- 理解所有蓝色线从这里开始

### 场景2：判断支撑强度
- 如果当前价格接近某条蓝色线
- 且该线有高匹配得分（如K3, K7匹配）
- 该价位可能是支撑位

### 场景3：识别突破信号
- 价格突破多条蓝色线
- 且锚定点已远离
- 可能是上涨趋势确立

### 场景4：对比两种算法
- 同时查看蓝色线图（AnchorBack）
- 和紫色线图（AnchorM）
- 找共同匹配的价位
- 作为更可靠的交易参考

## 成功案例

### 案例1：603036 如通股份
- 锚定点A=8.29 (2024-02-07)
- 最佳N=0.65
- 匹配10个K值：K1, K3, K7, K12, K15, K17, K19等
- 平均得分18.4分

### 案例2：002082 万邦德
- 锚定点A=3.93 (2024-02-07)
- 最佳N=0.31
- 匹配10个K值
- 价格沿蓝色线运行，验证了支撑位有效性

## 注意事项

1. **锚定点可见性**: 
   - 大部分股票能成功显示锚定点标注
   - 少数股票因锚定点太早（超出750根K线限制）而不显示

2. **K线数量限制**:
   - 最多显示750根K线（避免图表过于密集）
   - 如果数据超过750根，会截取最近的750根

3. **ZigZag参数**:
   - 阶段低点检测：49%
   - 转折点匹配：15%（可在`lineConfig.json`中调整）

4. **中文字体**:
   - 锚定点标签使用英文 "Anchor" 避免乱码
   - 其他中文文字（标题、行业）显示正常

## 技术参数

- **图表尺寸**: 20 × 8 英寸（更紧凑）
- **线程数**: 默认4，可通过`--workers`参数调整
- **输出格式**: PNG
- **字体**: Heiti TC, PingFang HK, Arial Unicode MS
- **配色方案**: 红涨绿跌，蓝色AnchorBack线

## 文件说明

- `draw_line_back.py`: 主脚本
- `lineConfig.json`: 配置文件
- `draw_line_back.log`: 运行日志
- `stocklist.csv`: 股票基础信息（名称、行业、PE、总股本等）

## 与draw_lines_mid.py的对比

| 项目 | draw_line_back.py | draw_lines_mid.py |
|------|------------------|-------------------|
| 算法 | AnchorBack (加法) | AnchorM (乘法) |
| 线条颜色 | 蓝色 | 紫色 |
| 信息框颜色 | 蓝色 | 紫色 |
| K值序列 | 奇数，自动生成 | 连续，自动生成 |
| 参数名 | N (步长) | M (百分比) |
| 配置节 | anchorBackLines | anchorMLines |
| 日志文件 | draw_line_back.log | draw_lines_mid.log |
| 输出目录 | {date}-drawLineBack | {date}-drawLineMid |
| 锚点窗口 | 11天 | 11天 |

## 建议

1. **同时使用两种算法**:
   - 加法模型（AnchorBack）和乘法模型（AnchorM）
   - 提供不同视角的支撑/阻力位分析
   
2. **关注共同匹配点**:
   - 如果两种算法都在某个价位匹配到高分
   - 该价位可能是更可靠的支撑/阻力位

3. **结合实际走势**:
   - 观察价格是否沿线条运行
   - 验证算法的有效性

---

# AnchorBack更新日志

## 2025-10-23 版本 2.0

### 核心改进

#### 1. 🚀 移除K值上限限制，自动覆盖所有K线

**之前的限制**：
- 固定使用配置文件中的 `k_list: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`
- 最多只画10条线
- 如果股价波动范围大，无法完全覆盖

**现在的策略**：
```python
# 自动计算需要多少个K值才能覆盖到最高价
k_to_reach_max = int((max_price - A) / N)

# 确保K是奇数
if k_to_reach_max % 2 == 0:
    k_to_reach_max += 1

# 在覆盖最高价的基础上再加3个奇数（+2, +4, +6）
k_final = k_to_reach_max + 6
```

**实际效果**：
- **002028 思源电气**: 77条线（K=1,3,5...153），完全覆盖
- **600323 瀚蓝环境**: 29条线（K=1,3,5...59）
- **002664 信质集团**: 28条线（K=1,3,5...57）
- **002133 广宇集团**: 6条线（K=1,3,5,7,9,11）

#### 2. 📊 动态N值调整策略

**问题识别**：
- 某些股票使用配置的N值范围（0.23~0.68）可能只有0-1个匹配
- 匹配数太少导致参考价值降低

**新策略**：
```python
# 如果匹配数<2，尝试降低N值以获得>=2个匹配
if best_N is None or best_result['matches_count'] < 2:
    # 找出所有匹配数>=2的N值
    valid_N_ge2 = {N: result for N, result in N_results.items() 
                   if result['matches_count'] >= 2}
    
    if valid_N_ge2:
        # 优先选择更小的N值（密集度更高）
        sorted_N = sorted(valid_N_ge2.items(), 
                        key=lambda x: (x[1]['avg_score'], 
                                      x[1]['matches_count'],
                                      -x[0]),  # 负号=优先小N
                        reverse=True)
        best_N, best_result = sorted_N[0]
```

**调整规则**：
1. **优先目标**: 匹配数 >= 2
2. **次要考虑**: 平均得分高
3. **第三考虑**: N值更小（线条更密集，更精细）

**日志示例**：
```
📊 [股票代码] 动态调整：降低N值以获得>=2个匹配 → N=0.35, 匹配数=3
```

#### 3. 🔧 锚定点A的计算改进

**之前的方法**：
- 在ZigZag检测到的低点前后3根K线（共7根）内
- 取最低收盘价作为锚定点A

**现在的方法**：
- 找到ZigZag检测到的低点对应的**日期**
- 在该日期前后5天（共11天）内
- 取所有收盘价中的最小值作为锚定点A

**改进原因**：
- 更准确地捕捉真实的局部低点
- 避免因K线数量不足导致的锚点偏差
- 提供更稳定的支撑位参考

### 技术细节

#### generate_B_series_back 方法改进

**之前**：
```python
for k in k_list:  # 固定列表
    B_k = A + N * k
    if B_k <= max_price * 1.2:
        B_values.append(B_k)
        K_values.append(k)
```

**现在**：
```python
# 生成奇数序列：1, 3, 5, 7, 9, ...
k = 1
while k <= k_final:  # 动态计算的终点
    B_k = A + N * k
    B_values.append(B_k)
    K_values.append(k)
    k += 2  # 每次加2，保持奇数
```

#### compute_anchor_back_lines 方法改进

新增了完整的N值筛选逻辑：

```python
# 5. 选择最佳N值（动态调整策略）
best_N, best_result = self.select_best_N(N_results, min_matches, prefer_higher_N)

# 动态调整：如果匹配数<2，降低N值
if best_N is None or best_result['matches_count'] < 2:
    valid_N_ge2 = {...}  # 找>=2匹配的N值
    
    if valid_N_ge2:
        # 选择最佳N（优先小N）
        best_N, best_result = sorted_N[0]
    else:
        # 至少选择匹配数最多的
        sorted_by_matches = sorted(...)
        best_N, best_result = sorted_by_matches[0]
```

### 实战对比

#### 案例1：002028 思源电气（大范围波动）

**修改前**：
- N = 0.68
- K值：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]（固定10条）
- 最高线：B_19 = A + 0.68 × 19
- 问题：无法覆盖到最高价

**修改后**：
- N = 0.68
- K值：1, 3, 5, ... , 151, 153（共77条）
- 最高线：B_153 = A + 0.68 × 153
- ✅ 完全覆盖所有K线并超出3条

#### 案例2：002133 广宇集团（小范围波动）

**修改前**：
- 固定10条线（可能过多）

**修改后**：
- 只生成6条线（刚好够用）
- 减少了不必要的线条，图表更清晰

### 配置文件无需修改

虽然算法升级，但 `lineConfig.json` 中的配置仍然有效：

```json
"anchorBackLines": {
    "enabled": true,
    "zigzag_percent": 15,
    "pivot_window": 7,
    "n_range": {
        "start": 0.23,
        "end": 0.68,
        "step": 0.01
    },
    "k_list": [1, 3, 5, 7, 9, 11, 13, 15, 17, 19],  // 现在仅用于确定奇数规则
    "match_tolerance_ratio": 0.006,
    "min_matches": 2,
    "tiebreaker_prefer_higher_N": true
}
```

**注意**：`k_list` 参数现在仅用于表明K值采用奇数序列规则，实际生成的K值数量由算法自动计算。

### 性能影响

#### 计算量
- **增加**：某些股票需要计算更多K值（如77条）
- **优化**：通过矢量化操作，性能影响不大
- **实测**：245只股票处理时间约4-5分钟（2线程）

#### 图表质量
- ✅ **覆盖更完整**：所有价格区间都有参考线
- ✅ **匹配更准确**：动态调整N值，确保>=2个匹配点
- ✅ **标注更清晰**：K值标签自动适应线条数量

### 使用建议

#### 1. 查看线条数量
```python
# 左上角信息框会显示：
# Matches: 8/77  (8个匹配点，共77条线)
```

#### 2. 理解N值调整
- 如果日志显示 "动态调整：降低N值"，说明原N值匹配数不足
- 调整后的N值能提供更多参考点

#### 3. 对比不同股票
- 线条多（如77条）：N值大或价格波动范围大
- 线条少（如6条）：N值小或价格波动范围小

### 已知问题与解决方案

#### Q: K值过多导致图表密集？
A: 已设置上限501条线，且大多数股票在6-30条范围内，图表仍然清晰。

#### Q: 如何恢复固定K值模式？
A: 可以修改 `generate_B_series_back` 方法，但不推荐，因为自动模式更灵活。

#### Q: N值调整是否会影响一致性？
A: 调整是为了保证>=2个匹配点，提高参考价值。如果需要完全一致，可以在配置中设置 `min_matches: 2`。

### 测试结果

#### 测试环境
- 日期：2025-10-22
- 股票数量：245只
- 线程数：2
- 处理时间：~4分钟

#### 统计数据
- ✅ 成功：245只（100%）
- 平均线条数：~15条
- 最多线条：77条（002028 思源电气）
- 最少线条：6条（002133 广宇集团）

#### 动态调整触发
- 约10-15%的股票触发了N值动态调整
- 所有调整后的股票匹配数>=2

### 升级指南

#### 自动升级
直接运行即可，无需修改配置：
```bash
python draw_line_back.py --date 2025-10-22 --workers 4
```

#### 如果遇到问题
1. 检查 `lineConfig.json` 中 `anchorBackLines.enabled` 是否为 `true`
2. 查看日志中的 "动态调整" 信息
3. 对比新旧图片，观察线条数量变化

### 未来优化方向

1. **智能密度控制**：当K值过多时，自动调整显示密度
2. **多N值对比**：同时显示多个N值的结果
3. **自适应容差**：根据价格范围动态调整匹配容差

---

## 2025-10-23 版本 1.0

### 初始功能
- ✅ 创建AnchorBack画线脚本
- ✅ 实现 `B = A + N × K` 算法
- ✅ 添加锚定点标注（红色圆点+黄色标签）
- ✅ 修复显示范围问题，确保锚定点可见
- ✅ 优化图层顺序（zorder=10）
- ✅ 完成245只股票的测试

---

**文档版本**: 1.0  
**最后更新**: 2025-10-24  
**作者**: AI Assistant  
**状态**: ✅ 稳定版本

